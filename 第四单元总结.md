# BUAA OO 第四单元总结
## 正向建模与开发
1. 本单元的核心思路是使用UML进行正向建模,然后根据建模结果进行编程,相当于把人脑中的思路用图的形式表达出来,再转换为代码.在实践过程中,我发现,仅仅单独先写UML和先写代码这两种方式都不可取,二者应当是相辅相成,互相交织的关系.首先,我会通过阅读指导书大致构思出来本次作业所需的类,类的属性,类的方法以及类之间的关系,然后将其转化为UML类图,形成一个草稿,这里仅仅包括最简单的信息,重要的是体现出类的框架,为后续编程提供参考.然后,我会根据类图开始编程,逐渐的我会发现我之前设计的类图很简略,所需的属性和方法也在逐渐增多,甚至可能出现需要增加一个类的情况,这时,我会再次修改UML类图,并进行一定的扩充,然后再用于编程,如此反复,最终形成UML-代码一致的效果.而第一次作业得到的类图是后续作业的基本框架,因此后续迭代可以参考类图,清晰明了
2. 状态图和顺序图,出现在第二三次作业,在已经形成大框架的前提下,可以在编程前直接写出状态图和顺序图,然后根据图来编程.状态图侧重于Book的转移,因此凡是涉及到Book的移动,都要体现在状态图上.顺序图主要体现在通过方法实现类与类之间的交互,同样可以用于体现出Book的转移


## 架构设计
![alt text](image.png)
本次作业的架构设计主要依据指导书所提及的几个区域,包括借还处,阅读室,书架,预约处.此外,我还设计了Library类,Library类是设计的核心,从属性上,拥有几个区域的唯一实例,相当于实际中一个图书馆,管理着下设的多个机构,从方法上,负责具体执行用户的各种请求,包括借书,还书,阅读等,将这些请求再分发到各个具体的机构中来执行,执行后,输出相应结果.

本单元考察的核心就是Book的转移,因此我设计了Book类,在初始时就创建相应数量的Book,之后,不在创建新的Book对象,Book只需要在各个机构之间转移.例如,每个机构类的add方法都需要以Book为传入参数,然后把Book放入自己类的容器里面.相对应的,每个remove方法只需要传入书籍的ISBN号,因为remove意味着取书,而用户在取书的时候是不需要指定副本号的,remove方法的返回值是返回一个特定副本号的Book对象.

为了实现借书前的判断操作以及信誉系统,我设计了Student类,属性包括他所借的全部书籍,信誉分等,方法包括判断该Student是否有资格借书以及为他增减信誉分等.由于输入数据并没有在一开始指定学生对象,因此每当出现一个新的学生ID我才创建一个学生对象

此外,为了设计的架构更加清晰,我还增添了QueryMachine,负责查询书的路径信息

闭关,开馆时的整理也是本单元的重点,从实际情况出发,最合理的选择是把整理都放在开馆.如果某一天用户预约了一本书籍,选在闭关时整理,如果图书馆间隔很长一段时间才开馆,那么就会被判定为逾期,为了提升成功率,选择在开馆的时候进行整理,更加符合实际.对于热门书籍的移动,可以考虑在前一天将热门书籍的ISBN记录在数组当中,第二天开馆整理的时候,先把需要转移的Book全部移动到书架当中,最后再把书架当中的热门书籍统一移动到热门书架


## 大模型辅助正向建模
我认为大模型在本学期的OO课程作用可以分为两部分
1. 首先,大模型可以用来进行架构设计,也可以理解为设计一个类图.在之前,我用大模型设计架构时总是不理想.根据实验课的学习,我学习到了可以采用ROSES框架,按照Role,ObjectiveScenario,Expected Solution,Steps这五步进行.对大模型的提问首先要告诉大模型需要承担一个怎样的角色,然后明确设计目标,明确整体的设计背景,提出具体要求,最后,可以对大模型的思考步骤提出要求,让它生成的结果更符号预期
2. 其次,大模型还可以用来做一些更加"微观"的事情,例如,给出某个算法,判断此时需要使用什么数据结构,如何对某个方法进行优化.这也是我在本学期课程中频繁使用的.


## 架构设计思维的演进
1. 第一单元: 本单元主要遇到两个困难,一个是半个学期不使用java语言,对java的各种语法,设计思路已经变得陌生,二是大量使用到递归下降的思路,而递归往往非常抽象,思考起来容易陷入混乱.通过参考往届同学的博客并和周围同学讨论,我逐步领会到了表达式解析的核心思路.先要对词法进行分析,就是把一个英文字母或英文单词,识别成一个运算符号,然后进行语法分析,这也是本单元的难点,使用递归下降的思路,如果在解析表达式的时候遇到加减运算符号,就进入下一层,去解析项,在解析项的时候,如果遇到乘符号,就进入下一层,去解析因子,以此类推,逐步形成一个树.总而言之,本单元的最大收获就是学习到了递归下降的设计思路
2. 第二单元: 本单元的重点是多线程设计,难点是多线程本身具有不确定性,并且要做到避免死锁.应对多线程问题,可以采用生产者-消费者模型,输入数据就是生产者,电梯处理数据就是消费者,而中间的缓冲区是用来暂存电梯还未处理的输入数据.为了避免读写冲突,需要将``requestTable``中的相关方法全部设置为同步方法,即使用``synchronized``关键字进行修饰,这样以来,读写就实现了分离.在学习完操作系统后,我发现多线程本质上就是要实现线程同步和线程互斥这两大问题,而``requestTable``的角色类似于OS当中的管程,是一种比PV操作更高级,更独立的单元.在本单元第三次作业中,我遇到了死锁问题,死锁问题的触发概率很低,但是错误是很致命的.经过反复查找,我发现是在处理双轿厢换乘层问题时,两个电梯线程各自持有锁且都需要获取对方的锁来释放锁,这就触发了死锁.本单元最大的收获是从无到有,学习了多线程的设计思路,实现了线程安全,当然,这只是最基础的多线程问题,也仅仅使用了``synchronized``锁,还有很多更复杂的问题与模型等待探索
3. 第三单元: 本单元的难点不再于学习什么新的知识点,而是对程序的优化.本单元采用JML语言对类的方法,属性进行描述,因此,只要能看懂JML,就能设计出正确的代码,而JML语言的理解,类似于离散数学当中的语言,并不难理解.我把重点放在了性能优化上,在很多地方,要计算方法的时间开销,为了降低时间复杂度,我把很多地方都从ArrayList或是LinkedList改成了HashMap,这样查找的效率大大提升.此外,我还使用了"动态维护"和"改时更新"的优化思路,大大提升了查询时的效率.
4. 第四单元: 正如前文所述,本单元我学习到了UML正向建模,通过UML与编程互相协作,使得设计思路更加清晰,为后续迭代打下了基础

总结而言,这四个单元,我的思维演进是这样的: 第一单元关注设计方法(递归下降),这是针对一维的输入数据而言的;第二单元关注线程之间的交互问题,视角更加宏观;第三单元,学习到了优化方法,更加关注细节处理,精益求精;第四单元,视角进一步提高,关注的是整体建模问题

## 测试思维的演进
1. 第一单元: 本单元的测试思路主要聚焦于边界情况,测试数据未必有多复杂,但往往是容易忽略的地方,典型的例如0,1,x^0等,通过构造这些边界情况,我也意识到代码的设计要考虑周全,不能只关注复杂的数据点,而忽视了最基础的数据
2. 第二单元: 本单元的测试思路主要围绕着压力测试进行,考察多线程设计在短时间内处理大量请求的问题,这样密集型的数据更容易触发潜在的死锁问题,更加考验调度算法的设计.在实际测试中,我就是依靠压力测试,发现了程序中的死锁问题.同时,在一些极端情况下,程序运行会超时,这就引导我进一步修改调度算法
3. 第三单元: 本单元我主要通过构建评测机的方式进行测试,为了体现出性能优劣,要生成大量的数据,并且数据中增删改的内容较少,查找占大部分,符合实际,这样就可以看出在设计时是否考虑了"动态维护"和"改时更新"的原则.强测当中的许多数据也是有大量的查找,在其中一次作业中,我的某一个查找时间复杂度高,这就导致了总体运行了将近15s,在修改后,立刻降到了3s左右
4. 第四单元: 本单元我使用的是同学公布的评测机,本单元重点在于要体现出"交互性",因为每个人整理思路与取书顺序是不同的,因此在测试的时候要有针对性,针对不同的输出结果决定下一步输入数据


## 课程收获
经过一学期的历练,我认为我的设计与编程能力都有了很大的提升.首先,我看待问题的视角从面向过程转变为了面向对象;其次,随着学习的深入,我愈发关注类与类之间是否实现了"高内聚,低耦合",在第一二单元,我没有很深入的思考这个问题,导致不该出现在某个类的方法不合理的出现在这个类,进入到三四单元,我更加关注模块之间的独立性.第三,我学习到了很多重要的设计思路,从递归下降到多线程(生产者-消费者,读写模式),再到单例模式等,这些都是很实用的技能