# BUAA OO UNIT2 总结

## 一. 同步块的设置和锁的选择
1. 第一次作业: 一个生产者,六个消费者,通过构建生产者-消费者模型可知,中间需要存在六个"托盘",作为生产者和消费者交互的媒介,也就是本题目的请求队列``requestTable``,由于``DispatchThread``可以将请求分配个各个队列,是**写操作**,而``ElevatorThread``将读取每个队列,是**读操作**,因此为了避免读写冲突,需要将``requestTable``中的相关方法全部设置为同步方法,即使用``synchronized``关键字进行修饰,这样以来,读写就实现了分离. 值得注意的是,不是所有同步方法内都需要调用``notifyAll``,只有能够唤醒电梯等待的方法才需要调用``notifyAll``,例如``pushRequest``,如果读操作的方法仍可唤醒正在等待的电梯,电梯会再次循环进行判断,造成CPU资源的浪费
2. 第二次作业: 新增临时调度,一方面正在进行调度的电梯可将电梯中的乘客重新放到队列中,进行二次分配,另一方面,已经放入电梯等待队列的乘客也要进行重新分配,这就导致原来单一生产者变为了现在的多生产者. 由于需要重新分配,因此将原本的``requestTable``分成``mainQueue``和``subQueue``. 同理,为了避免读写冲突,仍然需要将各个方法加锁,同时要遵循需要唤醒再唤醒的原则,节省CPU资源
3. 第三次作业: 新增升级请求,将两个独立的电梯合并为双轿厢,在同一电梯井内运行.考虑同一电梯井内的两部电梯涉及到换乘层冲突的问题,因此一部电梯想要到达换乘层,但另一部电梯正在占据换乘层时,前者需要等待后者离开,这就需要调用``wait``,因此必须添加同步代码块,同时,当后者离开换乘层时,需要唤醒前者电梯,告知其可以移动,因此,这部分也需要添加同步代码块
``` java
synchronized (this) {
            while (friendEle != null && friendEle.getCurrentFloor() == goalFloor) { //换乘层被占据
                //wait
            }
        }
```

```java
if (this.friendEle != null) {
                synchronized (this.friendEle) {
                    if (......) {
                       //notifyAll
                    }
                }
            }
```

## 二. 调度器与线程交互
1. 第一次作业: 只需要将输入的请求按乘客目标电梯序号,分配给对应的电梯即可,因此调度器是可有可无的,可以直接在``InputThread``进行分配,但是考虑到后续迭代,我选择创建了一个``DispatchThread``类,暂时用于简单的调度,为后续做准备
![alt text](image.png)
2. 第二次作业: 乘客不再指定目标电梯,需要自己权衡利弊,分配给某一部电梯. 由于我在第一次作业已经创建了调度类,因此本次作业需要实现的就是调度算法,调度算法有很多种,主要有按顺序分配(从1-6循环),有随机分配(随机生成1-6中的一个数),调参法,自由竞争(Receive限制导致此方法失效),影子电梯. 考虑到按顺序分配和随机分配挑战性较低,而且容易损失性能,影子电梯较为复杂,最终我选择了适中的调参法,大致思路是综合考虑6部电梯的各个参数,人为给各个参数赋予权重,得出相对优解. 此次作业还规定,不能向正在进行调度的电梯分配乘客,这里我参考了一位学长的做法,仍然按照各个参数进行计算,如果此时的确适合分配给正在调度的电梯,那就将乘客放入一个"缓存队列",等电梯调度结束,再将缓存队列中的乘客转移到该电梯的等待队列. 在处理这种情况时,我选择在计算权重的函数中判断电梯是否正在调度,如果正在调度,则做为一个参数,这个参数权重较大,目的就是尽可能不向正在调度的电梯分配乘客,同时计算电梯调度要停靠的楼层,算出和当前乘客起始楼层的差值,作为距离参数
3. 第三次作业: 沿用第二次的分配思路,同时为正在更新的电梯增加一个"更新参数",道理同上
``` java
weight = 10000 - 50 * isScheduling - 50 * isUpdating - 50 * isMoved
                - 2 * elevator.getSubQueue().getAllPersonsCount()
                - 2 * elevator.getCurrentNum() - 4 * (elevator.getSpeed() / 100)
                - 3 * distance - 6 * needTransfer;
```
这是第三次作业我对各个参数权重的设置,正在调度和更新的电梯参数权重最大,之后考虑置否需要换成,电梯运行速度,最后是距离,电梯内乘客数,等待队列乘客数三个参数,全部采用扣分形式,选取分数最高的作为最理想的目标电梯,并将该名乘客分配给对应的电梯队列,电梯线程再从队列获取乘客


## 三. 架构分析
### UML类图
![alt text](p-0-1.png)
1. 第一次作业: ``InputThread``读取请求,通过``DispatchThread``分配给各个``RequestTable``,``ElevatorThread``读取``RequestTable``,``ElevatorThread``调用内置的``Strategy``类,获取电梯下一步运行策略,运行策略为"类LOOK"算法,在原有LOOK算法上,进行修改:**当电梯内无人且请求队列有人的时候,优先去接优先级最高的乘客**. 运行策略通过一个枚举类提供. 本次作业我认为重点是在于将``RequestTable``作为指针传递给分配线程和电梯线程,二者可以调用同一队列的方法
2. 第二次和第三次作业: 将原本的``requestTable``分成``mainQueue``和``subQueue``,其余部分改动不大

### UML协作图
![alt text](协作图-.png)

## 四. 三次作业的变与不变
### 变
变化的地方在于新增的SCHE和UPDATE需求,新增的需求产生了电梯线程和输入线程,电梯线程和分配线程,电梯线程之间的交互问题,因此也需要根据实际情况进行调整,例如:将原本的``requestTable``分成``mainQueue``和``subQueue``,实际上,第一作业也有主队列和子队列之分,但是分成两个类并不是多此一举,此举就是为了适应电梯和分配线程的交互,输入线程的停止标志是读到文件尾部,分配线程的停止标志由原来的"输入线程结束且主请求队列没有剩余",转变为"**输入线程结束且``mainQueue``中没有未成功出去的乘客**",这就需要在``mainQueue``中定义一个变量用来记录未成功出去的乘客的人数. 此外,在``subQueue``中,也要按顺序先获得SCHE和UPDATE,再获得乘客请求. 因此将请求队列分成两个类是十分合理的,各自负责自己特有的功能,同时二者也有一定的共性,契合二三次作业的需求,使代码更加易读

### 不变
电梯的运行策略不变,依然是改良版的LOOK算法. 电梯反转,移动,开关门,等待,结束四种行为本身的具体流程是基本不变的

## 五. 双轿厢同步改造与避免碰撞
### 同步改造
两个电梯本来是两个各自运行的线程,这就需要尽可能让两个电梯同时停下来,接受改造,再同时启动.我没有选择关闭原有线程,新增两个线程,我认为这适合将一个电梯"一分为二",也就是在一个电梯的基础上新增一部电梯,而不适合将两个位于各自电梯井内的电梯合并为一个双轿厢电梯. 我采用的是"一主一从"的策略,我选择B电梯为主电梯,A电梯为从电梯,将UPDATE指令分配给B,同时将A设置为"被移动"状态,类比为WAIT状态,什么都不做,然后在B内进行更新,具体表现为实现A,B电梯乘客下车,Receive取消,重置速度,重置楼层,一同启动. 可以将这个过程设想为B把A电梯"拉到"自己的电梯井内,把自己和对方的参数进行调整,然后移动到指定位置,准备后续运行,这样"一主一从"的思维模式有助于实现这种合并问题,实现线程间的交互问题.此外,**由于这种方法天然存在的无法实现绝对意义上的同步进行,我选择在B电梯调用UPDATING方法的一开始,通过循环检查,等待A进入MOVED状态,直到A进入,这样就可以视为同步改造了**
```java
    //电梯B在UPDATE状态
    //但是,电梯A未必在MOVED状态，如果不在MOVED，下一次循环必然会到MOVED，但是此时二者不同步
    //因此B主动等待，等A循环一次进入到MOVED再开始
    while (elevatorA.getAdvice() != Advice.MOVED) {
        try {
            //System.out.println("主动等待，因为A还没有进入MOVED状态");
            sleep(800); //A执行一次循环,进入下一状态所需时间明显小于800ms
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
```

### 避免碰撞
在此处,我将问题设想为: 被合并的电梯其实没有真正被合并过去,仍然在各自原先的电梯井进行移动,只不过新增了限制条件: 二者不能同时位于指定的一层,二者移动的范围被缩小到指定范围. 这样以来,我只需要在电梯类里面添加一个``friendEle``变量,A和B互相是对方的``friendEle``,想要到达换乘层,但又被``friendEle``占据时等待,电梯离开换乘层的时候唤醒``friendEle``,这样就可以避免两个电梯的碰撞问题

## 六. DEBUG
我认为我遇到的BUG可分为以下四点:
1. 分配算法不合理导致运行超时: 这点可以通过调整参数的权重来尽量避免
2. 局部代码顺序有误,不符合题目要求: 我认为这是我遇到过最多的BUG,但同时由于有公开的数据点和错误信息,这一类型的BUG又很好修复,例如:
```java
    TimableOutput.println("UPDATE-END-" + aid + "-" + bid);

    elevatorB.getSubQueue().deleteFirstUpdate(); //最后才能结束阻塞
```
这里必须在结束UPDATE后才能将Sub中的UPDATE指令删除,如果在输出END之前删除,可能分配线程因检测到该电梯的队列没有UPDATE元素,因此向该电梯分配乘客,这就会输出Receive,导致错误
3. 逻辑错误导致超时: 在第三次作业中,我因为在一处增减楼层时未跳过0层,导致电梯卡在0层不动,最终超时
4. 死锁导致超时: 如果该电梯和该电梯的"同伴电梯"同时调用该方法,电梯A通过``synchronized (this)``获取自己的锁,同样电梯B获取自己的锁,在A调用``friendEle.getCurrentFloor()``又需要获取B的锁,同理B也需要获取A的锁,这就引发了死锁问题. 这也是我遇到的最难查的BUG,触发率极低,在BUG修复的时候,我原封不动交了三次,最终竟然顺利通过. 我想对应的解决方案可以是新增一个"协调控制类",用锁这个类的方法代替``friendEle.getCurrentFloor()``,这样就可以避免死锁问题,我打算之后作此尝试
``` java
public void IncreaseFloor() {
    int goalFloor = (currentFloor == -1) ? 1 : currentFloor + 1;
    synchronized (this) {
        while (friendEle != null && friendEle.getCurrentFloor() == goalFloor) { //换乘层被占据
            try {
                    this.wait(); //wait() 等待唤醒
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
        }   
    }
    currentFloor = goalFloor;
}
```

## 七. 心得体会
### 线程安全
这一方面,我认为既不能不加锁又不能乱加锁,这也是多线程问题难点之一,不加锁会导致读写冲突,乱加锁很容易引发死锁问题,因此,二者的平衡是需要在实践中不断摸索,反思,总结的. 多线程本身具有很高的随机性,因此我认为要多用print法,将一些涉及到线程安全的关键节点的信息打印出来,将结果与代码进行比对,有助于DEBUG

### 层次化设计
这方面我做的不够好,电梯类越写越多最终达到了将近500行,首先要承认的是,大部分内容都有必要写在电梯类里面,我想到的一个改进办法就是把关于换乘层问题的处理单开一个类进行协调

### 总结
多线程单元的三次作业让我受益匪浅,这既是我自身努力的成果,也是老师和助教耐心指导,同学之间积极讨论的结果